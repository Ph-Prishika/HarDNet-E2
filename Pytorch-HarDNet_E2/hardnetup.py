import os
import torch
import torch.nn as nn
import torch.nn.functional as F

class Flatten(nn.Module):
    def __init__(self):
        super().__init__()
    def forward(self, x):
        return x.view(x.data.size(0),-1)

class CombConvLayer(nn.Sequential):
    def __init__(self, in_channels, out_channels, kernel=1, stride=1, dropout=0.1, bias=False):
        super().__init__()
        self.add_module('layer1',ConvLayer(in_channels, out_channels, kernel))
        self.add_module('layer2',DWConvLayer(out_channels, out_channels, stride=stride))
        
    def forward(self, x):
        return super().forward(x)

class DWConvLayer(nn.Sequential):
    def __init__(self, in_channels, out_channels, stride=1, bias=False):
        super().__init__()
        self.add_module('dwconv', nn.Conv2d(in_channels, in_channels, kernel_size=3,
                                            stride=stride, padding=1, groups=in_channels, bias=bias))
        self.add_module('norm', nn.BatchNorm2d(in_channels))
    def forward(self, x):
        return super().forward(x)  

class ConvLayer(nn.Sequential):
    def __init__(self, in_channels, out_channels, kernel=3, stride=1, dropout=0.1, bias=False):
        super().__init__()
        self.add_module('conv', nn.Conv2d(in_channels, out_channels, kernel_size=kernel,          
                                          stride=stride, padding=kernel//2, bias=bias))
        self.add_module('norm', nn.BatchNorm2d(out_channels))
        self.add_module('relu', nn.ReLU6(inplace=True))                                          
    def forward(self, x):
        return super().forward(x)

class HarDBlock(nn.Module):
    def get_link(self, layer, base_ch, growth_rate, grmul):
        if layer == 0:
            return base_ch, 0, []
        out_channels = growth_rate
        link = []
        for i in range(10):
            dv = 2 ** i
            if layer % dv == 0:
                k = layer - dv
                link.append(k)
                if i > 0:
                    out_channels *= grmul
        out_channels = int(int(out_channels + 1) / 2) * 2
        in_channels = 0
        for i in link:
            ch, _, _ = self.get_link(i, base_ch, growth_rate, grmul)
            in_channels += ch
        return out_channels, in_channels, link

    def get_out_ch(self):
        return self.out_channels

    def __init__(self, in_channels, growth_rate, grmul, n_layers, keepBase=False, residual_out=False, dwconv=False):
        super().__init__()
        self.keepBase = keepBase
        self.links = []
        layers_ = []
        self.out_channels = 0
        for i in range(n_layers):
            outch, inch, link = self.get_link(i+1, in_channels, growth_rate, grmul)
            self.links.append(link)
            if dwconv:
                layers_.append(CombConvLayer(inch, outch))
            else:
                layers_.append(ConvLayer(inch, outch))
            if (i % 2 == 0) or (i == n_layers - 1):
                self.out_channels += outch
        self.layers = nn.ModuleList(layers_)
        
    def forward(self, x):
        layers_ = [x]
        for layer in range(len(self.layers)):
            link = self.links[layer]
            tin = [layers_[i] for i in link] if link else [layers_[0]]
            x = torch.cat(tin, 1) if len(tin) > 1 else tin[0]
            out = self.layers[layer](x)
            layers_.append(out)
        
        t = len(layers_)
        out_ = [layers_[i] for i in range(t) if (i == 0 and self.keepBase) or (i == t-1) or (i % 2 == 1)]
        return torch.cat(out_, 1)

class HarDNet(nn.Module):
    def __init__(self, depth_wise=False, arch=85, pretrained=True, weight_path=''):
        super().__init__()
        first_ch = [48, 96]
        grmul = 1.7
        drop_rate = 0.2

        ch_list = [192, 256, 320, 480, 720, 1280]
        gr = [24, 24, 28, 36, 48, 256]
        n_layers = [9, 17, 17, 17, 17, 5]  # Increased layers by one in each block
        downSamp = [1, 0, 1, 0, 1, 0]

        self.base = nn.ModuleList([
            ConvLayer(3, first_ch[0], stride=2),
            ConvLayer(first_ch[0], first_ch[1]),
            nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
        ])

        ch = first_ch[1]
        for i in range(len(n_layers)):
            blk = HarDBlock(ch, gr[i], grmul, n_layers[i], dwconv=depth_wise)
            ch = blk.get_out_ch()
            self.base.append(blk)
            self.base.append(ConvLayer(ch, ch_list[i], kernel=1))
            ch = ch_list[i]
            if downSamp[i] == 1:
                self.base.append(nn.MaxPool2d(kernel_size=2, stride=2))

        self.base.append(nn.Sequential(
            nn.AdaptiveAvgPool2d((1, 1)),
            Flatten(),
            nn.Dropout(drop_rate),
            nn.Linear(ch, 1000)
        ))

    def forward(self, x):
        for layer in self.base:
            x = layer(x)
        return x
